// SPDX-License-Identifier: AGPL-3.0-or-later

/*
Stagecraft - Stagecraft is a Go-based CLI that orchestrates local-first development and scalable single-host to multi-host deployments for multi-service applications powered by Docker Compose.

Copyright (C) 2025  Bartek Kus

This program is free software licensed under the terms of the GNU AGPL v3 or later.

See https://www.gnu.org/licenses/ for license details.

*/

package docs

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"stagecraft/internal/tools/features"
	"stagecraft/internal/tools/specschema"
)

// GenerateFeatureOverview generates docs/features/OVERVIEW.md from features.yaml and spec files.
func GenerateFeatureOverview(featuresPath, specRoot, outPath string) error {
	// Load features
	graph, err := features.LoadGraph(featuresPath)
	if err != nil {
		return fmt.Errorf("failed to load features: %w", err)
	}

	// Load all specs to get additional metadata
	specs, err := specschema.LoadAllSpecs(specRoot)
	if err != nil {
		// Non-fatal: we can still generate without spec frontmatter
		specs = []specschema.Spec{}
	}

	// Create spec lookup map
	specMap := make(map[string]specschema.SpecFrontmatter)
	for _, spec := range specs {
		specMap[spec.Frontmatter.Feature] = spec.Frontmatter
	}

	// Generate markdown
	content := generateMarkdown(graph, specMap)

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write file
	if err := os.WriteFile(outPath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("failed to write overview file: %w", err)
	}

	return nil
}

// generateMarkdown generates the markdown content for the overview.
func generateMarkdown(graph *features.Graph, specMap map[string]specschema.SpecFrontmatter) string {
	var sb strings.Builder

	sb.WriteString("# Stagecraft Features Overview\n\n")
	sb.WriteString("This document is auto-generated from `spec/features.yaml` and spec file frontmatter.\n")
	sb.WriteString("Do not edit this file manually. Regenerate with:\n\n")
	sb.WriteString("```bash\n")
	sb.WriteString("go run ./cmd/gen-features-overview\n")
	sb.WriteString("```\n\n")

	// Group features by domain
	byDomain := make(map[string][]*features.FeatureNode)
	for _, node := range graph.Nodes {
		domain := inferDomain(node, specMap)
		byDomain[domain] = append(byDomain[domain], node)
	}

	// Sort domains
	domains := make([]string, 0, len(byDomain))
	for domain := range byDomain {
		domains = append(domains, domain)
	}
	sort.Strings(domains)

	// Generate table
	sb.WriteString("## Features by Domain\n\n")
	sb.WriteString("| ID | Domain | Status | Title | Dependencies |\n")
	sb.WriteString("|----|--------|--------|-------|---------------|\n")

	for _, domain := range domains {
		nodes := byDomain[domain]
		sort.Slice(nodes, func(i, j int) bool {
			return nodes[i].ID < nodes[j].ID
		})

		for _, node := range nodes {
			deps := strings.Join(node.DependsOn, ", ")
			if deps == "" {
				deps = "-"
			}
			sb.WriteString(fmt.Sprintf("| %s | %s | %s | %s | %s |\n",
				node.ID, domain, node.Status, node.Title, deps))
		}
	}

	sb.WriteString("\n")

	// Dependency graph section
	sb.WriteString("## Dependency Graph\n\n")
	sb.WriteString("The following DOT graph shows feature dependencies:\n\n")
	sb.WriteString("```dot\n")
	sb.WriteString(features.ToDOT(graph))
	sb.WriteString("```\n\n")

	// Status summary
	sb.WriteString("## Status Summary\n\n")
	statusCounts := make(map[string]int)
	for _, node := range graph.Nodes {
		statusCounts[node.Status]++
	}

	sb.WriteString("| Status | Count |\n")
	sb.WriteString("|--------|-------|\n")
	for _, status := range []string{"done", "wip", "todo"} {
		count := statusCounts[status]
		sb.WriteString(fmt.Sprintf("| %s | %d |\n", status, count))
	}

	return sb.String()
}

// inferDomain tries to infer the domain from spec frontmatter or feature structure.
func inferDomain(node *features.FeatureNode, specMap map[string]specschema.SpecFrontmatter) string {
	// Try spec frontmatter first
	if fm, ok := specMap[node.ID]; ok && fm.Domain != "" {
		return fm.Domain
	}

	// Infer from spec path
	if node.Spec != "" {
		parts := strings.Split(node.Spec, "/")
		if len(parts) > 0 {
			return parts[0]
		}
	}

	// Default
	return "unknown"
}
