#!/usr/bin/env bash
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# Stagecraft - Stagecraft is a Go-based CLI that orchestrates local-first development and scalable single-host to multi-host deployments for multi-service applications powered by Docker Compose.
#
# Copyright (C) 2025  Bartek Kus
#
# This program is free software licensed under the terms of the GNU AGPL v3 or later.
#
# See https://www.gnu.org/licenses/ for license details.
#
# Pre-commit hook: Auto-formats code and adds license headers
# Escape hatch: Set STAGECRAFT_SKIP_HOOKS=1 to bypass (e.g., STAGECRAFT_SKIP_HOOKS=1 git commit)

set -e

# Escape hatch: allow bypassing hooks (namespaced to avoid conflicts)
if [ "${STAGECRAFT_SKIP_HOOKS:-}" = "1" ] || [ "${SKIP_HOOKS:-}" = "1" ]; then
    echo "⚠️  Skipping pre-commit hooks (STAGECRAFT_SKIP_HOOKS=1 or SKIP_HOOKS=1)"
    exit 0
fi

# Verbose mode (optional)
VERBOSE="${HOOK_VERBOSE:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

info() {
    echo "${GREEN}✓${NC} $1"
}

warn() {
    echo "${YELLOW}⚠${NC} $1"
}

error() {
    echo "${RED}✗${NC} $1" >&2
}

verbose() {
    if [ -n "$VERBOSE" ]; then
        echo "  [verbose] $1"
    fi
}

# Get project root (where .git directory is)
PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$PROJECT_ROOT"

# Get list of staged files using null-delimited format (handles spaces/newlines)
staged_files=$(git diff --cached --name-only -z --diff-filter=ACM 2>/dev/null | tr '\0' '\n' || true)

if [ -z "$staged_files" ]; then
    # No staged files, nothing to do
    exit 0
fi

# Filter staged Go files (using newline-based list for consistency)
staged_go_files=""
while IFS= read -r file; do
    [ -z "$file" ] && continue
    case "$file" in
        *.go)
            staged_go_files="$staged_go_files$file"$'\n'
            ;;
    esac
done <<EOF
$staged_files
EOF
staged_go_files=$(echo "$staged_go_files" | sed '/^$/d')

# === 1. Auto-organize imports with goimports (FIRST, before formatting) ===
imports_modified=""
if [ -n "$staged_go_files" ]; then
    if command -v goimports >/dev/null 2>&1; then
        info "Organizing imports with goimports..."
        verbose "Processing staged Go files only (staged-only mode)"

        # Process only staged files (not entire directories)
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            [ ! -f "$file" ] && continue
            verbose "  Processing: $file"
            if goimports -w -local stagecraft "$file" 2>/dev/null; then
                imports_modified="$imports_modified$file"$'\n'
            fi
        done <<EOF
$staged_go_files
EOF

        # Re-stage files that were modified
        if [ -n "$imports_modified" ]; then
            echo "$imports_modified" | while IFS= read -r file; do
                [ -z "$file" ] && continue
                git add "$file"
            done
            info "Imports organized"
        fi
    else
        warn "goimports not found, skipping import organization (install: go install golang.org/x/tools/cmd/goimports@latest)"
    fi
fi

# === 2. Auto-format Go files with gofumpt (AFTER imports, gofumpt is final authority) ===
formatted_files=""
if [ -n "$staged_go_files" ]; then
    if [ -x "$PROJECT_ROOT/scripts/goformat.sh" ]; then
        info "Formatting Go files with gofumpt (via scripts/goformat.sh)..."
        verbose "Using canonical formatting script"
        
        # Run the canonical formatting script
        if bash "$PROJECT_ROOT/scripts/goformat.sh" 2>/dev/null; then
            # Re-stage all Go files that might have been formatted
            while IFS= read -r file; do
                [ -z "$file" ] && continue
                [ ! -f "$file" ] && continue
                git add "$file"
            done <<EOF
$staged_go_files
EOF
            info "Go files formatted"
        else
            error "Formatting failed. Run ./scripts/goformat.sh manually"
            exit 1
        fi
    elif command -v gofumpt >/dev/null 2>&1; then
        # Fallback to direct gofumpt if script not available
        warn "scripts/goformat.sh not found, using gofumpt directly"
        verbose "gofumpt is the final formatting authority (runs after goimports)"

        # Format only staged files, using while-read for safety
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            [ ! -f "$file" ] && continue
            verbose "  Formatting: $file"
            if gofumpt -w "$file" 2>/dev/null; then
                formatted_files="$formatted_files$file"$'\n'
            fi
        done <<EOF
$staged_go_files
EOF

        # Re-stage formatted files
        if [ -n "$formatted_files" ]; then
            echo "$formatted_files" | while IFS= read -r file; do
                [ -z "$file" ] && continue
                git add "$file"
            done
            info "Go files formatted"
        fi
    else
        error "Neither scripts/goformat.sh nor gofumpt found. Install gofumpt: go install mvdan.cc/gofumpt@v0.6.0"
        exit 1
    fi
fi

# === 3. Auto-add license headers ===
# Files that need full headers (entry points)
FULL_HEADER_FILES="cmd/stagecraft/main.go cmd/stagecraftd/main.go internal/version/version.go"

# Files to ignore (generated, test scripts, testdata fixtures, etc.)
IGNORE_PATTERNS="internal/providers/backend/generic/test_script.sh testdata/ *.testdata.yaml *.testdata.yml"

if command -v addlicense >/dev/null 2>&1; then
    # Filter staged files that need headers (using newline-based list for space safety)
    files_needing_headers=""

    while IFS= read -r file; do
        [ -z "$file" ] && continue
        [ ! -f "$file" ] && continue

        # Skip if not a file type that needs headers
        case "$file" in
            *.go|*.sh|*.yaml|*.yml)
                # Skip testdata files (test fixtures shouldn't have license headers)
                if echo "$file" | grep -q "/testdata/"; then
                    continue
                fi
                
                # Check if file should be ignored (use -F for literal matching)
                skip=false
                for pattern in $IGNORE_PATTERNS; do
                    if [ "$file" = "$pattern" ] || echo "$file" | grep -Fq "$pattern"; then
                        skip=true
                        break
                    fi
                done
                [ "$skip" = true ] && continue

                # Check if file already has SPDX header
                if ! grep -q "SPDX-License-Identifier" "$file" 2>/dev/null; then
                    # Check if it's an entry file (needs full header)
                    is_entry=false
                    for entry_file in $FULL_HEADER_FILES; do
                        if [ "$file" = "$entry_file" ]; then
                            is_entry=true
                            break
                        fi
                    done

                    if [ "$is_entry" = true ]; then
                        warn "Entry file $file needs full header - please add manually (see CONTRIBUTING.md)"
                        warn "Skipping auto-add for entry files to avoid incorrect format"
                    else
                        files_needing_headers="$files_needing_headers$file"$'\n'
                    fi
                fi
                ;;
        esac
    done <<EOF
$staged_files
EOF

    if [ -n "$files_needing_headers" ]; then
        info "Adding license headers to files..."
        verbose "Using addlicense with AGPL template"

        # Build ignore arguments
        ignore_args=""
        for pattern in $IGNORE_PATTERNS; do
            ignore_args="$ignore_args -ignore $pattern"
        done

        # Process files one at a time using here-doc (no pipe = no subshell)
        # This ensures header_added and exit 1 work correctly
        header_added=false
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            [ ! -f "$file" ] && continue

            verbose "  Adding header to: $file"
            if addlicense -c 'Bartek Kus' -l agpl -y 2025 $ignore_args "$file" 2>/dev/null; then
                git add "$file"
                header_added=true
            else
                error "Failed to add license header to $file"
                error "You can skip this check with: STAGECRAFT_SKIP_HOOKS=1 git commit"
                exit 1
            fi
        done <<EOF
$files_needing_headers
EOF

        if [ "$header_added" = true ]; then
            info "License headers added"
        fi
    fi
else
    warn "addlicense not found, skipping license header check (install: go install github.com/google/addlicense@latest)"
fi

# === 4. Detect unstaged modifications (safety net) ===
# Check if any unstaged files were modified by our tools
unstaged_modified=$(git diff --name-only 2>/dev/null | grep -E '\.(go|sh|yaml|yml)$' || true)

if [ -n "$unstaged_modified" ]; then
    warn "There are unstaged changes in tracked files (possibly from formatting/import tools):"
    echo "$unstaged_modified" | sed 's/^/  - /'
    warn "Please review these changes before continuing"
    warn "Stage any you want to include with: git add <file>"
fi

# === 5. Quick build check on changed packages ===
if [ -n "$staged_go_files" ]; then
    info "Running quick build check..."

    # Get unique package directories from staged files (safely)
    changed_packages=""
    while IFS= read -r file; do
        [ -z "$file" ] && continue
        pkg_dir=$(dirname "$file" | sed 's|^\./||' | grep -v '^$')
        [ -n "$pkg_dir" ] && changed_packages="$changed_packages$pkg_dir"$'\n'
    done <<EOF
$staged_go_files
EOF
    changed_packages=$(echo "$changed_packages" | sort -u | sed '/^$/d')

    if [ -n "$changed_packages" ]; then
        # Try to build each changed package
        build_failed=false
        while IFS= read -r pkg_dir; do
            [ -z "$pkg_dir" ] && continue
            # Skip if directory doesn't exist or has no Go files
            [ ! -d "$pkg_dir" ] && continue
            [ -z "$(find "$pkg_dir" -maxdepth 1 -name "*.go" -type f 2>/dev/null)" ] && continue

            verbose "  Building package: $pkg_dir"
            if ! go build "./$pkg_dir" >/dev/null 2>&1; then
                error "Build failed for package: $pkg_dir"
                build_failed=true
            fi
        done <<EOF
$changed_packages
EOF

        if [ "$build_failed" = true ]; then
            error "Build check failed - please fix compilation errors"
            error "You can skip this check with: STAGECRAFT_SKIP_HOOKS=1 git commit"
            exit 1
        fi
        info "Build check passed"
    fi
fi

# === Governance checks (optional but recommended) ===
# Source: .hooks/pre-commit-gov-snippet.sh
# Escape hatch: Set SKIP_GOV_PRE_COMMIT=1 to bypass
if [ "${SKIP_GOV_PRE_COMMIT:-}" != "1" ] && [ -x "$PROJECT_ROOT/scripts/gov-pre-commit.sh" ]; then
    if ! bash "$PROJECT_ROOT/scripts/gov-pre-commit.sh"; then
        error "Governance pre-commit checks failed"
        error "Fix the issues above, or skip with: SKIP_GOV_PRE_COMMIT=1 git commit"
        exit 1
    fi
fi

info "Pre-commit checks passed"
